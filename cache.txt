%{
#include <iostream>
#include <vector>
#include "AST.h"
#include "SymTable.h"

using namespace std;

extern int yylineno;
extern int yylex();
void yyerror(const char*);

SymTable* currentSym;
%}

%union {
    int intVal;
    float floatVal;
    char* strVal;
    ASTNode* ast;
}

%token IF ELSE WHILE
%token PRINT
%token TRU FLS
%token AND OR NOT
%token EQ NEQ LT LE GT GE
%token ASSIGN

%token <intVal> INT_CONST
%token <floatVal> FLOAT_CONST
%token <strVal> ID

%type <ast> expr logic_expr stmt stmt_list

%left OR
%left AND
%left EQ NEQ LT LE GT GE
%left '+' '-'
%left '*' '/' '%'
%right NOT
%right UMINUS

%start program

%%

program
    : stmt_list {
        for (ASTNode* s : *((vector<ASTNode*>*)$1)) {
            if (s) s->eval(*currentSym);
        }
      }
    ;

stmt_list
    : stmt {
        $$ = new vector<ASTNode*>();
        ((vector<ASTNode*>*)$$)->push_back($1);
      }
    | stmt_list stmt {
        ((vector<ASTNode*>*)$1)->push_back($2);
        $$ = $1;
      }
    ;

stmt
    : ID ASSIGN expr ';' {
        $$ = new ASTAssign(new ASTId($1), $3);
      }
    | PRINT '(' expr ')' ';' {
        $$ = new ASTPrint($3);
      }
    | IF '(' logic_expr ')' stmt {
        $$ = new ASTNull();
      }
    | IF '(' logic_expr ')' stmt ELSE stmt {
        $$ = new ASTNull();
      }
    | WHILE '(' logic_expr ')' stmt {
        $$ = new ASTNull();
      }
    | '{' stmt_list '}' {
        $$ = new ASTNull();
      }
    ;

logic_expr
    : expr EQ expr   { $$ = new ASTBinaryOp("==", $1, $3); }
    | expr NEQ expr  { $$ = new ASTBinaryOp("!=", $1, $3); }
    | expr LT expr   { $$ = new ASTBinaryOp("<",  $1, $3); }
    | expr LE expr   { $$ = new ASTBinaryOp("<=", $1, $3); }
    | expr GT expr   { $$ = new ASTBinaryOp(">",  $1, $3); }
    | expr GE expr   { $$ = new ASTBinaryOp(">=", $1, $3); }
    | logic_expr AND logic_expr { $$ = new ASTBinaryOp("&&", $1, $3); }
    | logic_expr OR  logic_expr { $$ = new ASTBinaryOp("||", $1, $3); }
    | NOT logic_expr { $$ = new ASTUnaryOp("not", $2); }
    | '(' logic_expr ')' { $$ = $2; }
    | TRU { $$ = new ASTConstant(Value::makeBool(true)); }
    | FLS { $$ = new ASTConstant(Value::makeBool(false)); }
    ;

expr
    : expr '+' expr { $$ = new ASTBinaryOp("+", $1, $3); }
    | expr '-' expr { $$ = new ASTBinaryOp("-", $1, $3); }
    | expr '*' expr { $$ = new ASTBinaryOp("*", $1, $3); }
    | expr '/' expr { $$ = new ASTBinaryOp("/", $1, $3); }
    | expr '%' expr { $$ = new ASTBinaryOp("%", $1, $3); }
    | '-' expr %prec UMINUS { $$ = new ASTUnaryOp("-", $2); }
    | '(' expr ')' { $$ = $2; }
    | INT_CONST { $$ = new ASTConstant(Value::makeInt($1)); }
    | FLOAT_CONST { $$ = new ASTConstant(Value::makeFloat($1)); }
    | ID { $$ = new ASTId($1); }
    ;

%%

void yyerror(const char* s) {
    cout << "Error: " << s << " at line " << yylineno << endl;
}

int main() {
    currentSym = new SymTable("global");
    yyparse();
    delete currentSym;
    return 0;
}